# 流摹 (LiuMo) 前端架构规划方案 V8.0

> **版本**: V8.0  
> **状态**: 已归档  
> **日期**: 2026-01-30  
> **关联**: 
> - [后端规划方案 V8.0](./liumo-assets-prep/后端规划方案.md)
> - [技术方案 V7.1](./技术方案.md)
> - [规划方案 V1.6.x](./规划方案.md)

---

## 一、概述

### 1.1 目标
基于后端 V8.0 统一 JSON Schema，重构前端架构，实现：
- 策略模式布局引擎
- 虚拟列表高性能渲染
- 精简数据结构，删除冗余字段

### 1.2 核心原则
1. **直达最终版本**：一次性重构到位，不做中间兼容
2. **分步验证**：每部分构建无报错后，再进行下一部分
3. **后端定义前端遵循**：`content_json` 结构由后端定义，前端直接使用

---

## 二、数据结构（复用后端定义）

### 2.1 后端已定义的 content_json 结构

```typescript
// 后端定义，前端直接复用
interface Paragraph {
  type: 'main' | 'small' | 'indent';
  lines: string[];
}

interface StructuredContent {
  paragraphs: Paragraph[];
}
```

### 2.2 前端 Poetry 类型

```typescript
// src/types/poetry.ts
export interface Poetry {
  id: string;
  title: string;
  author: string;
  dynasty: string;
  
  // V8.0 核心字段
  layout_strategy: 'GRID_STANDARD' | 'FLOW_VARYING' | 'CENTER_ALIGNED';
  content_json: string;  // 后端返回的 JSON String，前端解析
  
  // 辅助字段
  tags: string[];        // 标签数组
}
```

**变更说明**：
- ✅ 新增：`layout_strategy`（必填）
- ✅ 新增：`content_json`（必填）
- ❌ 删除：`content`（冗余，已包含在 content_json 中）
- ❌ 删除：`type`（冗余，已包含在 tags 中）
- ❌ 删除：`display_content`（冗余，前端从 content_json 生成）

---

## 三、架构设计

### 3.1 策略模式目录结构

```
src/utils/layoutEngine/
├── index.ts                 # 策略工厂导出
├── types.ts                 # 类型定义
├── virtualScroll.ts         # 虚拟滚动工具
└── strategies/
    ├── index.ts            # 策略导出
    ├── gridStrategy.ts     # 网格布局（GRID_STANDARD）
    ├── flowStrategy.ts     # 流式布局（FLOW_VARYING）
    └── centerStrategy.ts   # 居中对齐（CENTER_ALIGNED）
```

### 3.2 类型定义

```typescript
// src/utils/layoutEngine/types.ts

/** 布局策略枚举 */
export type LayoutStrategy = 
  | 'GRID_STANDARD'    // 标准网格（5言/7言绝句律诗）
  | 'FLOW_VARYING'     // 流式布局（词/曲/行长不固定）
  | 'CENTER_ALIGNED';  // 居中对齐（古文/散文）

/** 段落类型（复用后端定义） */
export type ParagraphType = 'main' | 'small' | 'indent';

/** 单个段落 */
export interface Paragraph {
  type: ParagraphType;
  lines: string[];
}

/** 结构化内容（复用后端定义） */
export interface StructuredContent {
  paragraphs: Paragraph[];
}

/** 渲染项 */
export interface RenderItem {
  char: string;
  x: number;
  y: number;
  row: number;
  col: number;
  paragraphType: ParagraphType;
}

/** 布局配置 */
export interface LayoutConfig {
  fontSize: number;
  lineHeight: number;
  charWidth: number;
  gridSize: number;
  paddingTop: number;
  paddingBottom: number;
  columns: number;
}

/** 布局结果 */
export interface LayoutResult {
  items: RenderItem[];
  totalHeight: number;
  lineOffsets: number[];
  getViewportItems: (scrollTop: number, viewHeight: number) => RenderItem[];
}

/** 抽象策略接口 */
export interface ILayoutStrategy {
  calculate(content: StructuredContent, config: LayoutConfig): LayoutResult;
}
```

---

## 四、策略实现

### 4.1 Grid Strategy（网格布局）

```typescript
// src/utils/layoutEngine/strategies/gridStrategy.ts
import type { ILayoutStrategy, LayoutResult, StructuredContent, LayoutConfig, RenderItem } from '../types';

export const gridStrategy: ILayoutStrategy = {
  calculate(content: StructuredContent, config: LayoutConfig): LayoutResult {
    const items: RenderItem[] = [];
    const lineOffsets: number[] = [];
    let currentY = config.paddingTop;
    let row = 0;

    for (const para of content.paragraphs) {
      for (const line of para.lines) {
        lineOffsets.push(currentY);
        
        for (let col = 0; col < line.length; col++) {
          items.push({
            char: line[col],
            x: col * config.gridSize,
            y: currentY,
            row: row++,
            col,
            paragraphType: para.type
          });
        }
        currentY += config.gridSize;
      }
    }

    return {
      items,
      totalHeight: currentY + config.paddingBottom,
      lineOffsets,
      getViewportItems: (scrollTop, viewHeight) => {
        // Grid 策略：行高固定，二分查找
        const startY = scrollTop - 50; // 轻预渲染
        const endY = scrollTop + viewHeight + 50;
        
        return items.filter(item => 
          item.y >= startY && item.y < endY
        );
      }
    };
  }
};
```

### 4.2 Flow Strategy（流式布局）

```typescript
// src/utils/layoutEngine/strategies/flowStrategy.ts
import type { ILayoutStrategy, LayoutResult, StructuredContent, LayoutConfig, RenderItem } from '../types';

export const flowStrategy: ILayoutStrategy = {
  calculate(content: StructuredContent, config: LayoutConfig): LayoutResult {
    const items: RenderItem[] = [];
    const lineOffsets: number[] = [];
    let currentY = config.paddingTop;
    let row = 0;

    for (const para of content.paragraphs) {
      lineOffsets.push(currentY);
      
      for (const line of para.lines) {
        // 计算每行实际宽度（支持变长）
        const lineWidth = line.length * config.charWidth;
        const startX = (config.columns * config.charWidth - lineWidth) / 2; // 居中
        
        for (let col = 0; col < line.length; col++) {
          items.push({
            char: line[col],
            x: startX + col * config.charWidth,
            y: currentY,
            row: row++,
            col,
            paragraphType: para.type
          });
        }
        
        // 根据段落类型和字号计算行高
        const lineHeight = para.type === 'small' 
          ? config.lineHeight * 0.8 
          : config.lineHeight;
        currentY += lineHeight;
      }
    }

    return {
      items,
      totalHeight: currentY + config.paddingBottom,
      lineOffsets,
      getViewportItems: (scrollTop, viewHeight) => {
        // Flow 策略：二分查找 + 轻预渲染
        const startY = scrollTop - 100;
        const endY = scrollTop + viewHeight + 100;
        
        // 二分查找起始索引
        let startIdx = 0;
        let left = 0, right = items.length - 1;
        while (left <= right) {
          const mid = Math.floor((left + right) / 2);
          if (items[mid].y < startY) {
            startIdx = mid;
            left = mid + 1;
          } else {
            right = mid - 1;
          }
        }
        
        // 收集可视区域内的项
        const visible: RenderItem[] = [];
        for (let i = startIdx; i < items.length; i++) {
          if (items[i].y > endY) break;
          visible.push(items[i]);
        }
        return visible;
      }
    };
  }
};
```

### 4.3 Center Strategy（居中对齐）

```typescript
// src/utils/layoutEngine/strategies/centerStrategy.ts
import type { ILayoutStrategy, LayoutResult, StructuredContent, LayoutConfig, RenderItem } from '../types';

export const centerStrategy: ILayoutStrategy = {
  calculate(content: StructuredContent, config: LayoutConfig): LayoutResult {
    // 类似 Flow，但始终居中，更适合散文
    const items: RenderItem[] = [];
    const lineOffsets: number[] = [];
    let currentY = config.paddingTop;
    let row = 0;

    for (const para of content.paragraphs) {
      lineOffsets.push(currentY);
      
      for (const line of para.lines) {
        const lineWidth = line.length * config.charWidth;
        const startX = (config.columns * config.charWidth - lineWidth) / 2;
        
        for (let col = 0; col < line.length; col++) {
          items.push({
            char: line[col],
            x: startX + col * config.charWidth,
            y: currentY,
            row: row++,
            col,
            paragraphType: para.type
          });
        }
        
        currentY += config.lineHeight;
      }
    }

    return {
      items,
      totalHeight: currentY + config.paddingBottom,
      lineOffsets,
      getViewportItems: (scrollTop, viewHeight) => {
        const startY = scrollTop - 100;
        const endY = scrollTop + viewHeight + 100;
        
        return items.filter(item => 
          item.y >= startY && item.y < endY
        );
      }
    };
  }
};
```

---

## 五、策略工厂

```typescript
// src/utils/layoutEngine/index.ts
import { gridStrategy } from './strategies/gridStrategy';
import { flowStrategy } from './strategies/flowStrategy';
import { centerStrategy } from './strategies/centerStrategy';
import type { ILayoutStrategy, LayoutStrategy, StructuredContent, LayoutConfig, LayoutResult } from './types';

const strategies: Record<LayoutStrategy, ILayoutStrategy> = {
  GRID_STANDARD: gridStrategy,
  FLOW_VARYING: flowStrategy,
  CENTER_ALIGNED: centerStrategy,
};

export function useLayoutEngine() {
  const config = ref<LayoutConfig>({
    fontSize: 24,
    lineHeight: 36,
    charWidth: 24,
    gridSize: 24,
    paddingTop: 40,
    paddingBottom: 40,
    columns: 20,
  });

  function calculate(
    content: StructuredContent, 
    strategy: LayoutStrategy = 'CENTER_ALIGNED'
  ): LayoutResult {
    const strategyFn = strategies[strategy] || strategies.CENTER_ALIGNED;
    return strategyFn.calculate(content, config.value);
  }

  return {
    config,
    calculate,
  };
}
```

---

## 六、虚拟列表实现

### 6.1 虚拟滚动工具

```typescript
// src/utils/layoutEngine/virtualScroll.ts
import type { RenderItem } from './types';

export function getViewportItems(
  items: RenderItem[],
  lineOffsets: number[],
  scrollTop: number,
  viewHeight: number,
  preRender: number = 100
): RenderItem[] {
  const startY = scrollTop - preRender;
  const endY = scrollTop + viewHeight + preRender;
  
  return items.filter(item => 
    item.y >= startY && item.y < endY
  );
}

export function binarySearchStartIndex(
  items: RenderItem[],
  targetY: number
): number {
  let left = 0;
  let right = items.length - 1;
  let result = 0;
  
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    if (items[mid].y < targetY) {
      result = mid;
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  
  return result;
}
```

### 6.2 PaperCanvas.vue 改造

```vue
<!-- src/components/PaperCanvas.vue -->
<template>
  <div 
    ref="containerRef" 
    class="paper-canvas"
    @scroll="onScroll"
  >
    <!-- 占位元素，撑开滚动高度 -->
    <div :style="{ height: `${totalHeight}px`, width: '100%' }"></div>
    
    <!-- 实际渲染层 -->
    <div 
      class="render-layer"
      :style="{ transform: `translateY(${-scrollTop}px)` }"
    >
      <CharacterCell
        v-for="item in visibleItems"
        :key="`${item.row}-${item.col}`"
        :char="item.char"
        :x="item.x"
        :y="item.y"
        :font-size="config.fontSize"
        :line-height="config.lineHeight"
      />
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted } from 'vue';
import { usePoetryStore } from '@/stores/poetry';
import { useLayoutEngine } from '@/utils/layoutEngine';
import { getViewportItems } from '@/utils/layoutEngine/virtualScroll';
import CharacterCell from './CharacterCell.vue';

const containerRef = ref<HTMLElement>();
const scrollTop = ref(0);
const viewHeight = ref(800);

const poetryStore = usePoetryStore();
const { config, calculate } = useLayoutEngine();

// 计算布局
const layoutResult = computed(() => {
  if (!poetryStore.currentPoetry) return null;
  return calculate(poetryStore.parsedContent, poetryStore.layoutStrategy);
});

const totalHeight = computed(() => layoutResult.value?.totalHeight || 0);

// 虚拟列表：即时渲染 + 轻预渲染
const visibleItems = computed(() => {
  if (!layoutResult.value) return [];
  return getViewportItems(
    layoutResult.value.items,
    layoutResult.value.lineOffsets,
    scrollTop.value,
    viewHeight.value,
    100 // 轻预渲染：上下各多渲染 100px
  );
});

// 滚动事件处理
const onScroll = (e: Event) => {
  const target = e.target as HTMLElement;
  scrollTop.value = target.scrollTop;
  viewHeight.value = target.clientHeight;
};

// ResizeObserver 监听视口变化
let resizeObserver: ResizeObserver;
onMounted(() => {
  resizeObserver = new ResizeObserver((entries) => {
    for (const entry of entries) {
      viewHeight.value = entry.contentRect.height;
    }
  });
  if (containerRef.value) {
    resizeObserver.observe(containerRef.value);
  }
});

onUnmounted(() => {
  resizeObserver?.disconnect();
});
</script>

<style scoped>
.paper-canvas {
  position: relative;
  width: 100%;
  height: 100%;
  overflow-y: auto;
  overflow-x: hidden;
}

.render-layer {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  will-change: transform;
}
</style>
```

---

## 七、数据流改造

### 7.1 poetry.ts Store

```typescript
// src/stores/poetry.ts
import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { Poetry } from '@/types/poetry';
import { parseContentJson } from '@/utils/contentParser';
import type { StructuredContent } from '@/utils/layoutEngine/types';

export const usePoetryStore = defineStore('poetry', () => {
  const currentPoetry = ref<Poetry | null>(null);
  const searchResults = ref<Poetry[]>([]);

  // V8.0: 解析 content_json（必填）
  const parsedContent = computed<StructuredContent | null>(() => {
    if (!currentPoetry.value?.content_json) return null;
    return parseContentJson(currentPoetry.value.content_json);
  });

  // V8.0: 使用 layout_strategy
  const layoutStrategy = computed(() => {
    return currentPoetry.value?.layout_strategy || 'CENTER_ALIGNED';
  });

  // V8.0: 辅助函数：生成纯文本（用于摘要/搜索）
  const plainText = computed(() => {
    if (!parsedContent.value) return '';
    return parsedContent.value.paragraphs
      .map(p => p.lines.join(''))
      .join('\n');
  });

  return {
    currentPoetry,
    searchResults,
    parsedContent,
    layoutStrategy,
    plainText,
  };
});
```

### 7.2 contentParser.ts

```typescript
// src/utils/contentParser.ts
import type { StructuredContent } from './layoutEngine/types';

export function parseContentJson(jsonString: string): StructuredContent {
  try {
    return JSON.parse(jsonString);
  } catch (e) {
    console.error('Failed to parse content_json:', e);
    return { paragraphs: [] };
  }
}
```

---

## 八、实施计划

### 8.1 阶段一：类型与解析层
| 任务 | 文件 | 状态 |
| ---- | ---- | ---- |
| 新增 | `src/utils/layoutEngine/types.ts` | 待办 |
| 新增 | `src/utils/contentParser.ts` | 待办 |
| 修改 | `src/types/poetry.ts` | 待办 |
| 修改 | `src/stores/poetry.ts` | 待办 |

### 8.2 阶段二：策略模式重构
| 任务 | 文件 | 状态 |
| ---- | ---- | ---- |
| 新增 | `src/utils/layoutEngine/strategies/` 目录 | 待办 |
| 新增 | `gridStrategy.ts` | 待办 |
| 新增 | `flowStrategy.ts` | 待办 |
| 新增 | `centerStrategy.ts` | 待办 |
| 修改 | `src/utils/layoutEngine/index.ts` | 待办 |

### 8.3 阶段三：虚拟列表
| 任务 | 文件 | 状态 |
| ---- | ---- | ---- |
| 新增 | `src/utils/layoutEngine/virtualScroll.ts` | 待办 |
| 修改 | `src/components/PaperCanvas.vue` | 待办 |

### 8.4 阶段四：集成测试
| 任务 | 说明 |
| ---- | ---- |
| 构建验证 | `npm run build` 无报错 |
| 回归测试 | 确保现有渲染行为不变 |
| 性能测试 | 虚拟列表 FPS > 55 |

---

## 九、验收标准

1. **类型安全**：TypeScript 编译无错误
2. **功能完整**：支持三种布局策略
3. **性能达标**：虚拟列表渲染 FPS > 55
4. **数据正确**：正确解析 V8.0 content_json

---

## 十、与后端方案的对应关系

| 后端规划 V8.0 | 前端对应实现 |
|--------------|-------------|
| `content_json` 必填 | `parseContentJson()` 解析 |
| `layout_strategy` 枚举 | 策略工厂三种实现 |
| FTS5 全文搜索 | 前端搜索框联动（可选） |
| 强制更新数据库 | 前端无兼容层，直接使用新结构 |

---

> **审批人**: ____________  
> **审批日期**: ____________  
> **审批意见**: ____________
